背包问题可以描述为: **给定一组物品, 每种物品都有自己的重量和价格, 在限定的总重量内, 我们如何选择, 才能使得物品的总价格最高.**

根据**每种物品的数量**, 可以将背包问题分为以下几种, 如下图所示:

- 01背包问题
- 完全背包问题
- 多重背包问题

![](/resources/images/problems/背包问题分类.png)

---

# 01背包

01背包是背包问题的基础, 可以阐述为: 有N件物品和一个容量为W的背包, 第i件物品的重量是w[i], 对应的价值为v[i], **每件物品只能用一次**, 求解将哪些物品装入背包里物品价值总和最大.

分析一下, 每件物品都存在装入和不装入两种情况, 因此如果使用暴力穷举法, 时间复杂度是$$O(2^N)$$. 使用动态规划的方法, 避免重复计算, 可以将时间复杂度降至$$O(NW)$$.

## 状态矩阵定义

对于背包问题, 我们定义一个二维状态矩阵`dp[i][j]`, 表示:

```
dp[i][j]表示将前i件物品装进限重为j的背包可以获得的最大价值, 0<=i<=N, 0<=j<=W
```

N和W都是可以被取到的, 即dp是一个大小为`(N + 1, W + 1)`的矩阵. `dp[0][j]`表示将第0号物品放入背包, 即不向背包中放入任何物品. `dp[i][0]`表示将第i个物品放入到容量为0的背包中.

## 矩阵初始化

接下来考虑初始化的情况. 对于`dp[0][j]`, 即不放任何物品到背包中, 对应的价值为0, 第0行全部初始化为0. `dp[i][0]`的背包容量为0, 放不下如何物品, 对应的价值也为0, 第0列全部初始化为0.

## 状态转移公式

考虑状态转移公式. 对于第i件物品, 有两种情况:

- 不将第i件物品放入背包中, 此时`dp[i][j] = dp[i - 1][j]`
- 在能装下的前提下, 将第i件物品放入背包中, 此时`dp[i][j] = dp[i - 1][j - w[i]] + v[i]`

因此`dp[i][j]`应为上面两者的较大值, 即`dp[i][j] = max(dp[i - 1][j - w[i]] + v[i], dp[i - 1][j])`

## 确定遍历顺序

由状态转移方程可知, `dp[i][j]`的值只与它的**上一行中当前位置的前半部分**`dp[i-1][0,...,j]`相关. 因此使用二维数组的情况下, 保证按行从上到下遍历, 然后左右的顺序就不重要了.

## 滚动数组

由于计算每个位置时, 只与上一行相关, 因此可以采用滚动数组, 对空间复杂度进行优化, 只保存一行, 空间复杂度降为$$O(W)$$. 这一行的长度为`W + 1`.

### 滚动数组的遍历顺序

需要注意的是, 对于每个位置j, 计算新值会覆盖前值, 因此对列循环时, j需要**从右向左**遍历. 如果从左向右遍历, 计算`dp[i][j]`时使用到的`dp[i][j-w[i]]`已经是同一行的结果了, 整个过程也就是错误的了.

使用滚动数组, 根据状态转移公式: `dp[j] = max(dp[j], dp[j - w[i]] + v[i])`, 一维数组也要全部初始化为0.

### 使用滚动数组的优点

除了直接的节省空间的目的, 使用二维数组, 在求`dp[i][j]`时, 还要考虑当前的重量j是否**不小于**当前物品i对应的重量`w[i]`, 如果小于的话肯定装不下一个i物品, 就只有状态转移中的第一种情况, 直接令`dp[i][j] = dp[i - 1][j]`. 即需要在对j遍历时增加一个**IF-ELSE**逻辑.

但使用了滚动数组, 本行的dp值首先直接继承了上一行的dp值. 因此对于`j < w[i]`的情况, `dp[j]`的值直接就是上一行的结果值, 因此:

- 遍历第i行时, 列j索引直接从w[i]开始, 之前的值已经是正确的了无需遍历
- 因为无需遍历`j < w[i]`的情况, 省去了IF-ELSE的逻辑

## 相关题目

- [[416][中等][动态规划] 分割等和子集](/docs/problems/动态规划/416-分割等和子集.md)

# 完全背包

完全背包与01背包不同就是**每种物品可以有无限多个**, 一共有N种物品, 每种物品有无限多个, 从第i种(i从1开始)的重量为`w[i]`, 价值为`v[i]`, 在总重量不超过背包承载上限W的情况下, 能够装入背包的最大价值是多少.

## 状态矩阵定义

我们的目标和变量和01背包没有区别, 所以可定义与01背包问题完全相同的状态矩阵dp:

```
dp[i][j]表示将前i件物品装进限重为j的背包可以获得的最大价值, 0<=i<=N, 0<=j<=W
```

## 矩阵初始化

初始状态也是一样的. 对于`dp[0][j]`, 即不放任何物品到背包中, 对应的价值为0, 第0行全部初始化为0. `dp[i][0]`的背包容量为0, 放不下如何物品, 对应的价值也为0, 第0列全部初始化为0.

## 状态转移公式及迭代顺序

### 按每一种物品迭代

按每种物品的维度考虑. 对于第i件物品`(i > 0)`, 01背包中只有取0件(不装)和1件(装入), 但完全背包可以装入0件, 1件, 2件, 直到超过限重. 因此最多可以装入`k = j // w[i]`件, 这里的`j`是求`dp[i][j]`时当前的背包容量限制.

因此状态转移方程, 需要考虑各种装入数量的情况, 即:

```python
# k为装入第i种物品的件数, k <= j/w[i]
dp[i][j] = max([dp[i - 1][j − k * w[i]] + k * v[i] for k in range(j // w[i] + 1)])
```

由于也是当前值只与上一行的值相关, 因此可以用滚动数组简化空间. 而且同01背包一样, 计算当前值会覆盖前值, 因此对列循环时, j需要**从右向左**遍历. 滚动数组更新的伪代码如下:

```c
// 完全背包问题思路二伪代码(空间优化版)
dp[0,...,W] = 0
for i = 1,...,N
    for j = W,...,w[i] // 必须逆向枚举!!!
        for k = [0, 1,..., j/w[i]]
            dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])
```

### 按每一次放入物品迭代

对于第i件物品, 有两种情况:

- 不放入任何一件第i件物品至背包中, 此时与01背包一样, `dp[i][j] = dp[i - 1][j]`
- 在能装下的前提下, **再放入一件第i件物品到背包中**, 此时`dp[i][j] = dp[i][j - w[i]] + v[i]`

需要注意的是, 与01背包对比, 第二种情况`dp[i−1][j−w[i]]`项应替换为`dp[i][j−w[i]]`. 为什么可以这么替代?

因为每件物品都有无数个, 根据状态转移矩阵的定义, `dp[i][j]`代表了前i件物品装进限重为j的背包可以获得的最大价值, 那么它综合了第i件物品, 在容量允许的情况下, 装0次, 1次, 2次, ..., `j // w[i]`次的情况. 其中0次对应的就是`dp[i - 1][j]`的值, 即`dp[i - 1][j]`只是`dp[i][j]`种的一种情况, `dp[i][j]`是考虑了`dp[i - 1][j]`后得到的值.

在01背包的问题中, 之所以使用`dp[i - 1][j]`是因为第i件物品只能装一次, 而现在考虑的就是在准备装第i件物品的前提下. 因此我们要找的位置`j−w[i]`一定是没有装过第i件物品的, 只装了前i-1件物品, 因此是`dp[i−1][j−w[i]]`. 如果使用`dp[i][j−w[i]]`, 这个综合了装0次和1次第i个物品的结果, 第i件物品就有可能装两次, 违背了题目的限制.

因此, 这种情况下的状态转移公式为:

```python
dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) # j >= w[i]
```

观察计算当前位置使用的是上一行的值, 以及本行位置j之前的值, 因此也可以使用滚动数组进行空间优化, 但需要注意的是, 使用这种方法进行的完全背包问题, 迭代的时候与01背包相反, 只能**从左向右正向迭代**, 因为使用位置j之前的值是使用的本行的值, 因此要先覆盖.

滚动数组更新的伪代码如下:

```c
// 完全背包问题思路一伪代码(空间优化版)
dp[0,...,W] = 0
for i = 1,...,N
    for j = w[i],...,W // 必须正向枚举!!!
        dp[j] = max(dp[j], dp[j−w[i]]+v[i])
```

## 相关题目

- [[279][中等][动态规划][BFS] 完全平方数](/docs/problems/动态规划/279-完全平方数.md)
- [[343][中等][动态规划] 整数拆分](/docs/problems/动态规划/343-整数拆分.md)
- [[面试题 08.11][中等][动态规划] 硬币](/docs/problems/动态规划/08.11-硬币.md)

# 多重背包

多重背包与前面不同就是每种物品是有限个, 一共有N种物品, 从第i种(i从1开始)物品的数量为`n[i]`, 重量为`w[i]`, 价值为`v[i]`, 在总重量不超过背包承载上限W的情况下, 能够装入背包的最大价值是多少.

状态矩阵定义, 初始化与之前一致. 重点是状态转移方程及迭代顺序.

## 按每一种物品迭代

与完全背包相同, 按每种物品的维度考虑. 对于第i件物品`(i > 0)`, 可以装入0件, 1件, 2件, 直到超过限重`k = j // w[i]`, 或达到`n[i]`的数量限制. 对应的状态转移方程为:

```python
# k为装入第i种物品的件数, k <= min(n[i], j/w[i])
dp[i][j] = max{(dp[i-1][j − k*w[i]] + k*v[i]) for every k}
```

同样对于滚动数组的形式, 需要**从右到左逆向迭代**, 对应的伪代码为:

```c
// 完全背包问题思路二伪代码(空间优化版)
dp[0,...,W] = 0
for i = 1,...,N
    for j = W,...,w[i] // 必须逆向枚举!!!
        for k = [0, 1,..., min(n[i], j/w[i])]
            dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])
```

## 不能复用完全背包的第二种情况

完全背包有以下的转移公式:

```python
dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) # j >= w[i]
```

这是因为完全背包每件物品的数量没有限制, 而`dp[i][j−w[i]]`融合了将第i件物品装0次, 1次, 2次, ..., `j // w[i]`次的各种情况, 本次再添加一件i物品, 是没有任何问题的.

但多重背包与01背包一样, 数量的限制使得计算`dp[i][j]`时不能使用`dp[i][j−w[i]]`. 在01背包中, `dp[i][j−w[i]]`, 这个综合了装0次和1次第i个物品的结果, 第i件物品就有可能装两次, 违背了题目的限制. 那么在多重背包中, `dp[i][j−w[i]]`可能已经综合了第i件物品装了`n[i]`次的情况, 如果再装一件, 也违背了题目的限制.

因此多重背包只能使用上面的方法, 多加一层对第i件物品加入次数的迭代来更新.

# 规整为01背包

**完全背包, 多重背包, 都可以转换为01背包.**

考虑第i件物品, 完全背包最多可以装入`W / w[i]`件, 多重背包最多可以装入`n[i]`件, 统一将第i件物品可装入的最大数量记为`N[i]`.

转换为01背包问题, 思路就是将第i种物品扩展为`N[i]`种物品, 即是否装入1件i物品, 是否装入2件i物品, ..., 是否装入`N[i]`件i物品. 每种物品对应的重量是`w[i] * k`, k是这种物品对应的装入第i件物品的数量, 对应的价值是`v[i] * k`. 这样每种物品都扩展为多种物品, 新的物品每个最多只能放入1件, 因此就转换为了01背包问题.

这样扩展出来的物品种类有些多, 在计算时可能带来效率问题. 可以进一步优化物品扩展方案, 降低转换后新物品种类的数量, 提高整体的计算效率.

核心思想是**二进制的思想**. 按照上面的扩展方案, 每种物品扩展得到的新物品之间是**互斥**的. 而二进制的思想是扩展得到的新物品可以**复用**, **组合得到装入物品i从1到`N[i]`的各种情况**.

例如某个物品i对应的最大数量为13, 对应的二进制数为`1101`(低位在右)的4位数字, 因此我们可以使用`0001`, `0010`, `0100`, `1000`这4个数表示`0000~1101`之间的任何一个数. 因此如果物品i对应的最大数量为13的情况下, 可以将其扩展为**装入数量为1**, **装入数量为2**, **装入数量为4**, **装入数量为8**这四种新物品, 就可以组合出装入`0~13`之中任何一种数量i物品的情况. 这样就将新物品的数量从13个降为4个.

总结下来, 就是将物品i扩展为, 装入$$2^k, \ k=1,2,\cdots, \text{and }w_i 2^k \le W$$个第i件物品, 作为新物品, 每个新物品对应的重量为$$w_i 2^k$$, 对应的价值为$$v_i 2^k$$.

对应的伪代码如下:

```python
# W背包的总容量, n是第i种物品的最大数量, w是第i种物品的重量, v是第i种物品的价值
k = 1  # k就是新物品对应的装入原物品i的数量
while n > 0:
    zero_one_pack_step(w, v, W)
    n -= k
    k = n if k * 2 > n else k * 2
```

上面的这种写法, 对应的最后一个新物品与旧物品的关系与上面有所区别. 例如对于13, 上面会分解成`0001, 0010, 0100, 1000`即`1, 2, 4, 8`四个物品, 而代码中的方法会分解成`1, 2, 4, 6`(`0001, 0010, 0100, 0110`). 这样依然可以, 是因为除了最后一个新物品6, 之前的物品`1, 2, 4`可以组成原来物品i最大数量13的中至少一半的数字, 即`(13 + 1) // 2 = 7`, `0~7`, 那么剩余的一半`8~13`, 可以通过13减去`0~7`得到, 即先假设`1, 2, 4, 6`都被占用, 然后将`1, 2, 4`中的某几个不装入即可.

# 背包问题的变种

## 恰好装满

基本的背包问题都是考虑在容量的限制下, 装入价值最大的物品, 只要最终装入物品的总容量小于背包容量即可.

背包问题有时候还有一个限制就是必须**恰好装满背包**, 即如果一种方案没有装满背包, 即使它的价值更大, 也不能作为最优解, 装满背包是最高限制条件.

这种问题在处理时与之前相比思路没有区别, 唯一的区别是**初始化时有所不同**. 基础的背包问题将dp所有位置初始化为0, 因此任何容量的背包都有一个**合法解`什么都不装`**, 且这个解的价值为0, 因此初始化为0.

但现在如果有了恰好装满这个限制, 那些装不满的情况就不符合限制, 不能作为一种方案. 为了表现这点, 我们将dp的值都初始化为`-inf`, 表示不可取. 求解`dp[i][j]`时依赖的前值如果都是`-inf`, 说明当前容量与当前可选物品找不到能恰好装满的组合, 对应的`-inf + v[i]`, 结果依然是`-inf`, 因此状态转移公式不用改变.

初始化时, 只有`dp[i][0]`或`dp[0]`(一维滚动数组)可以初始化为0, 即容量为0的背包可以被`恰好装满`, 其他情况都要初始化为`-inf`.

然后使用01背包或完全背包的逻辑求解.

### 相关题目

- [[322][中等][动态规划][DFS] 零钱兑换](/docs/problems/动态规划/322-零钱兑换.md)
- [[416][中等][动态规划] 分割等和子集](/docs/problems/动态规划/416-分割等和子集.md)

## 求方案总数

除了在给定每个物品的价值后求可得到的最大价值外, 还有一类问题是问装满背包或将背包装至某一指定容量的方案总数.

对于这类问题, 状态矩阵`dp[i][j]`的定义需要转变为使用前i种物品装入到容量为j的背包中的方案数量. 而状态转移公式中的`max`需要转换为`sum`, 因此当前物品装与不装, 都是可以选择的方案.

对应的状态转移公式为:

- 01背包: `dp[i][j] = sum(dp[i−1][j], dp[i-1][j−w[i]])`
- 完全背包: `dp[i][j] = sum(dp[i−1][j], dp[i][j−w[i]]) // j >= w[i]`

初始化也要变化下, `dp[i][0]`需要初始化为1, 因为容量为0的背包不放入任何一种物品就是唯一的方案. 滚动数组中就是将`dp[0]`初始化为1.

循环逻辑不变.

### 相关题目

- [[494][中等][动态规划] 目标和](/docs/problems/动态规划/494-目标和.md)
- [[518][中等][动态规划] 零钱兑换 II](/docs/problems/动态规划/518-零钱兑换-II.md)

## 二维背包

前面讨论的背包容量都是一个量, 即重量.二维背包问题是指每个背包**有两个限制条件**, 比如重量和体积限制, 选择物品必须要满足这两个条件. 此类问题的解法和一维背包问题不同就是dp数组要多开一维, 其他和一维背包完全一样.

即dp将变为三维张量, 即使使用滚动数组也要变为二维. 以滚动数组为例, 在求第i种物品时, 对应的`dp[j][k]`代表的是将前i种物品装入到重量限制为j, 体积限制为k的背包中最大的价值. 因此, 循环变为3层: `i, j, k`. 对应的状态转移公式为:

```python
dp[j][k] = max(dp[j][k], dp[j-w0[i]][k-w1[i]] + v[i])
```

### 相关题目

- [[474][中等][动态规划][背包] 一和零](/docs/problems/动态规划/474-一和零.md)

## 求最优方案

背包问题是要求一个最优值, 如果要求输出这个最优值的方案, 即要求输出都要装入哪些物品. 可以参照一般动态规划问题输出方案的方法: **记录下每个状态的最优值是由哪一个策略推出来的**, 这样便可根据这条策略找到上一个状态, 从上一个状态接着向前推即可.

可以再用一个数组`G[i][j]`. `G[i][j]`有两种取值, 如设定为`0`和`1`, 分别表示计算得到`dp[i][j]`时有没有用物品i, 即:

- `G[i][j] = 0`: 计算`dp[i][j]`时采用了`max`中的前一项`dp[i-1][j]`即没有用物品i
- `G[i][j] = 1`: 计算`dp[i][j]`时采用了`max`中的后一项`dp[i-1][j-w[i]]`(01背包)或`dp[i][j-w[i]]`(完全背包), 即使用了用物品i

这样我们就可以从`G[-1][-1]`一路倒推出最优方案的路径了.

# 参考资料

- [动态规划之背包问题系列](https://tangshusen.me/2019/11/24/knapsack-problem/)
