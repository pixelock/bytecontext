# 题目描述

[面试题 08.11. 硬币](https://leetcode.cn/problems/coin-lcci/)

给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

示例1:
```
输入: n = 5
输出：2
解释: 有两种方式可以凑成总金额:
5=5
5=1+1+1+1+1
```

示例2:
```
输入: n = 10
输出：4
解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1
```

说明：

注意, 你可以假设:

- 0 <= n (总金额) <= 1000000

# 解题思路

## 动态规划

一个完全背包问题, 也是求解背包方案数量的问题. 本题中可选的物品即为1分, 5分, 10分和25分4种硬币, 背包容量为给定的n分. 关键点在于状态转移公式和初始化的方法.

先从状态转移公式出发. 考虑j分的情况, 对应的状态`dp[j]`代表的是j分可以有几种分解方案. 遍历4种硬币, 作为最后一枚凑成j分的硬币(这是满足`j >= 25`的情况), 则j分可以由j - 1, j - 5, j - 10 和 j - 25 4种情况得来, 因此dp[j]就是dp[j - 1], dp[j - 5], dp[j - 10], dp[j - 25]4种情况之和. 以遍历的角度, 对应的状态转移公式为:

$$
\text{dp}[j] = \text{dp}[j] + \text{dp}[j-coin], \text{coin} \in [1, 5, 10, 25]
$$

考虑一种特殊的情况, 如果j分对应的就是4种面值硬币其中的一个, 则一个可行的拆分方案就是用这个硬币来拼凑成, 对应的状态为dp[0]. 由于0之后不可再拆分, 所以这种方案对应的数量为1. 因此可以将dp[0]的值初始化为1, 来避免特殊情况带来if-else的代码.

**唯一性保证**

比如对于6, 可以有1+5, 和5+1的顺序问题, 这两种是同一种方案, 上面的状态转移如何保证1+5不会因为顺序问题被记录两次?

按完全背包问题的常规遍历方法, i对应的是硬币的种类, j对应的当前的背包容量. 从上到下, 从左到右遍历. 对于`dp[1][6]`, 这里的1对应的是1分(2对应5分, 依次类推), 代表的是前1种硬币的方案数, 因此`dp[1][6] = 1`. 对于`dp[2][6]`, 我们要考虑的就是使用前两枚硬币的方案数, 由于只使用前1枚硬币的方案数已经在`dp[1][6]`中记录, 因此我们只需要考虑使用第2种硬币(5分钱)的情况, 所以需要融合`dp[2][1]`的方案, 对应的拆分为`6 = 1 + 5`.

发现没有, 按照这种从上到下的遍历方法, 我们只考虑了`1 + 5`的情况, 不会经过`5 + 1`的情况. 这是因为按硬币顺序做外循环, 先考虑低价值硬币的情况, 后考虑高价值硬币的情况, 相当于每种方案, 会将方案中低价值硬币先拆分出来, 形成低价值在前, 高价值在后的情况, 即`1 + 5`会出现, `5 + 1`不会出现.

```python
class Solution:
    def waysToChange(self, n: int) -> int:
        coins = [1, 5, 10, 25]

        dp = [0] * (n + 1)
        dp[0] = 1
        for coin in coins:
            for j in range(coin, n + 1):
                dp[j] += dp[j - coin]
        return dp[-1] % 1000000007
```
